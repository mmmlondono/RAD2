####READ ME####
# The purpose of this script is to run SNPfiltR protocol for aciurina smooth subset
####libraries####
library(SNPfiltR)
library(devtools)
devtools::install_github("DevonDeRaad/SNPfiltR")
library("adegenet")
library("vcfR")

####Read in files####
#VCF file
vcfR <- read.vcfR("rbrush/vcf_small/pop6.vcf")

#populations map file
popmap<-data.frame(id=colnames(vcfR@gt)[2:length(colnames(vcfR@gt))],pop=substr(colnames(vcfR@gt)[2:length(colnames(vcfR@gt))], 7,8))

####Implement quality filters####
#that donâ€™t involve missing data This is because removing low data samples will alter percentage/quantile based missing data cutoffs, so we wait to implement those until after deciding on our final set of samples for downstream analysis

#visualize distributions c
hard_filter(vcfR=vcfR)
#> no depth cutoff provided, exploratory visualization will be generated.

#hard filter to minimum depth of 5, and minimum genotype quality of 30
vcfR<-hard_filter(vcfR=vcfR, depth = 5, gq = 30)

##execute allele balance filter
vcfR<-filter_allele_balance(vcfR)

#visualize and pick appropriate max depth cutoff
max_depth(vcfR)

#filter vcf by the max depth cutoff you chose
vcfR<-max_depth(vcfR, maxdepth = 100)

#remove invariant SNPs generated during the genotype filtering steps
vcfR<-min_mac(vcfR, min.mac = 1)

#check vcfR to see how many SNPs we have left
vcfR

####cutoff for missing data allowed per sample####
#run function to visualize samples
missing_by_sample(vcfR=vcfR, popmap = popmap)

#run function to drop samples above the threshold we want from the vcf
vcfR<-missing_by_sample(vcfR=vcfR, cutoff = .80)

#subset popmap to only include retained individuals
popmap<-popmap[popmap$id %in% colnames(vcfR@gt),]

#remove invariant sites generated by dropping individuals
vcfR<-min_mac(vcfR, min.mac = 1)

#verify that missing data is not driving clustering patterns among the retained samples
miss<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap, thresholds = .8, clustering = FALSE)

####set missing data per SNP cutoff####
#visualize missing data by SNP and the effect of various cutoffs on the missingness of each sample
missing_by_snp(vcfR)

#check if these cutoffs prevent samples from clustering
#by patterns of missing data in a PCA
miss<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap,
                              thresholds = c(.5, .75,.85,.95), clustering = FALSE)

#check what t-SNE clustering looks like at an 85% threshold
miss<-assess_missing_data_tsne(vcfR=vcfR, popmap = popmap,
                               thresholds = c(.75,.85,.95), clustering = FALSE)


#choose a cutoff resulting in an acceptable amount of missing data in each sample, and maximizes SNPs retained while minimizing overall missing data, and filter vcf
vcfR<-missing_by_snp(vcfR, cutoff = .9)
#>cutoff is specified, filtered vcfR object will be returned

#check how many SNPs and samples are left
vcfR

####minor allele and linkage filtering####
#investigate clustering patterns with and without a minor allele cutoff
#use min.mac() to investigate the effect of multiple cutoffs
vcfR.mac<-min_mac(vcfR = vcfR, min.mac = 1)
#> 32.61% of SNPs fell below a minor allele count of 2 and were removed from the VCF

#assess clustering without MAC cutoff
miss<-assess_missing_data_tsne(vcfR, popmap, clustering = FALSE)

#assess clustering with MAC cutoff
miss<-assess_missing_data_tsne(vcfR.mac, popmap, clustering = FALSE)

###Finally, we will make sure that the depth and genotype quality look consistent across SNPs and samples, following our filtering pipeline.###
#plot depth per snp and per sample
dp <- extract.gt(vcfR, element = "DP", as.numeric=TRUE)
heatmap.bp(dp, rlabels = FALSE)

#plot genotype quality per snp and per sample
gq <- extract.gt(vcfR, element = "GQ", as.numeric=TRUE)
heatmap.bp(gq, rlabels = FALSE)

####write out vcf files for downstream analyses####
#write out vcf with all SNPs
vcfR::write.vcf(vcfR, "rbrushsmall.75.filtered.vcf.gz")
#linkage filter vcf to thin SNPs to one per 500bp
vcfR.thin<-distance_thin(vcfR, min.distance = 500)
#write out thinned vcf
vcfR::write.vcf(vcfR.thin, "rbrushsmall.75.thinned.vcf.gz")
